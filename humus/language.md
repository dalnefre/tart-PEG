# Actor Language Design

This document describes considerations for the design of a language for actor-oriented programming.

## What is actor-oriented programming?

The [Actor Model](https://en.wikipedia.org/wiki/Actor_model) describes computation by passing asynchronous messages between opaque computational elements (actors).
In response to a message that it receives, an actor can make local decisions, create more actors, send more messages, and designate how to respond to the next message received.
Since actor implementations are opaque, the "state" of an actor may only be inferred from its response to messages.

## Where are actors most useful?

## Why a new language?

## Primary language goals

## Key Questions

### How is an actor's state/behavior represented?
### What are the semantics of actor message-passing?

## Minimalism

The Actor Model is defined in terms of three primitive actions: **send**, **create**, and **become**.
A **send** action adds a pending _event_ to the configuration, consisting of a _message_ and a target actor _address_.
A **create** action adds a new actor to the configuration, with a uniquely defined _address_ and an initial _behavior_.
A **become** action, executed as part of an actor's _behavior_, designates a new _behavior_ for handling subsequent _messages_ to this actor.
Actor computation consists of taking an _event_ from the set of pending events 
and invoking the _behavior_ of the target actor to process the _message_.

### Actor Semantics

An actor _configuration_ consists of a set of pending _events_ **Q**, 
and a set of actors **A** mapping each actor's _address_ to its current _behavior_.
Note that **send** generates a unique _event_, even if it duplicates an existing target _address_ and _message_ pair.

    Action                       | Effect
    -----------------------------|------------------------------------------
    **send** _address_ _message_ | **Q** + <_address_, _message_>
    **create** _behavior_        | **A** + (_address_ -> _behavior_)
    **become** _behavior_        | **A** \| (`SELF` -> _behavior_)

The unique _address_ generated by **create** (designating the newly created actor) is made available to the currently executing actor.
The keyword `SELF` designates the address of the currently executing actor.

An actor _address_ is a unique opaque unforgable token that represents the capability to send a message to the actor.
An actor may come to know the address of another actor in three ways:

1. Provided as part of an actor's behavior (including access to `SELF`)
2. Generated when a new actor is created
3. Received as part of a message

The _behavior_ of an actor describes a set of _actions_ (which cause _effects_) taken by the actor when it receives a _message_.
The behavior has access to the contents of the message.
You can think of the behavior as being parameterized by the message.

A _message_ is an immutable data structure, which must be able to communicate (at least) an actor address.

### Send is Universal

The **send** action schedules work to be done in an actor system.
At any given time, the set of pending _events_ represents all the requested (but not completed) work.
It may be possible to describe both **create** and **become** in terms of **send**
by modeling execution of an meta-actor's behavior as a flurry of messages within a configuration of more basic machine-actors.
A meta-**create** would be accomplished by sending a _behavior_ to a machine-level _sponsor_ (ambient authority),
which would send the _address_ of the new actor as a response.
A meta-**become** would be accomplished by sending a _behavior_ to a machine-actor responsible for making the meta-actor ready to handle another message.

It may also be possible to represent all _messages_ and _behaviors_ as machine-actors.
This would lead to a universal actor representation (everything is an actor),
but raises the issue of "grounding out".
As some level, it must be possible to complete an action without generating additional events.
A meta-level message delivery could trigger a series of machine-level events,
and when there are no more machine-level events the meta-level message processing would be complete.

Ground-level machine-actors can be described as if they were meta-level actors,
in order to understand their intended behavior.
However, they may be implemented directly by the run-time machinery,
thus avoiding the generation of additional events.

#### _Message_ machine-actors

A meta-actor message is represented as a machine-level input stream.
The meta-actor receiving the message uses machine-level pattern matching 
to "parse" the message, understanding is structure and contents.

An input-stream machine-actor represents a position in the input source.
When given a _customer_, the stream responds with 
the _value_ at the current position and a machine-actor representing the _next_ position.
If the end of the input source is reached, the response is 
a distinguish actor representing the stream _end_.

#### _Behavior_ machine-actors

A meta-actor behavior is represented as a collection of machine-level primitive actions.
Primitive actions execute within a _context_.
The _context_ provides access to the machine-level _sponsor_ for creating new actors.
It also contains the results of pattern-matching the meta-_message_,
and the meta-_effects_ caused by machine-actions.

The most basic action is, of course, **send**.
A **send** takes an actor representing the _message_ and an actor representing the _target_.
From these, a meta-_event_ is added to the pending events in the _context_.
The _sponsor_ controls (and potentially limits) the resources required to deliver/process _events_.

